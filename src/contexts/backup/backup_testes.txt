/* useEffect(() => {
    const storedIntervalJobID = localStorage.getItem("intervalJobId");

    if (storedIntervalJobID) {
      const id = parseInt(storedIntervalJobID, 10);
      setIntervalJobId(id);
    }

    return () => {
      if (intervalJobId) {
        clearInterval(intervalJobId);
        localStorage.removeItem("intervalJobId");
      }
    };
  }, []);

  useEffect(() => {
    if (connection && !intervalJobId) {
      const idInterval = setInterval(() => {
        const jobsToStart = [0];

        jobsToStart.forEach(async () => {
          await startJob();
        });
      }, 30000);

      localStorage.setItem("intervalJobId", idInterval.toString());
      setIntervalJobId(idInterval);
    }
  }, [connection, intervalJobId, startJob]); */

  /*   useEffect(() => {
    if (connection) {
      const interval = setInterval(async () => {
        console.log("entrou aqui dentro do interval");
        await startJob();
      }, 30000);

      return () => clearInterval(interval);
    }
  }, [connection, startJob]); */

  const [jobsIniciados, setJobsIniciados] = useState(false);

  useEffect(() => {
    if (!jobsIniciados) {
      if (connection) {
        // Verificar se há um intervalo salvo no localStorage
        const storedIntervalStartTime =
          localStorage.getItem("intervalStartTime");

        if (storedIntervalStartTime) {
          const elapsedTime =
            Date.now() - parseInt(storedIntervalStartTime, 10);
          const remainingTime = 30000 - (elapsedTime % 30000);

          setTimeout(() => {
            // Iniciar o intervalo após o tempo restante
            const id = setInterval(async () => {
              // Iniciar todos os jobs do array
              const jobsToStart = [0];

              jobsToStart.forEach(async () => {
                await startJob();
              });
            }, 30000);

            // Armazenar o ID do intervalo no localStorage
            localStorage.setItem("intervalStartTime", Date.now().toString());
            return () => clearInterval(id);
          }, remainingTime);
        } else {
          // Se não houver intervalo salvo, inicie o intervalo normalmente
          const id = setInterval(async () => {
            // Iniciar todos os jobs do array
            const jobsToStart = [0];

            jobsToStart.forEach(async () => {
              await startJob();
            });
          }, 30000);

          // Armazenar o ID do intervalo no localStorage
          localStorage.setItem("intervalStartTime", Date.now().toString());
          return () => clearInterval(id);
        }
        setJobsIniciados(true);
      }
    }
  }, [connection, startJob, jobsIniciados]);







//oficial



 const [startTime, setStartTime] = useState(() => {
    const savedStartTime = localStorage.getItem("startTime:jobs");
    return savedStartTime ? parseInt(savedStartTime) : Date.now();
  });

  const [elapsedTime, setElapsedTime] = useState(0);

  useEffect(() => {
    if (connection) {
      const savedElapsedTime = localStorage.getItem("elapsedTime:jobs");
      if (savedElapsedTime) {
        const parsedElapsedTime = parseInt(savedElapsedTime);
        const currentTime = Date.now();
        const timeDifference = Math.floor((currentTime - startTime) / 1000);

        if (timeDifference > parsedElapsedTime) {
          const elapsedSeconds = parsedElapsedTime + timeDifference;
          setElapsedTime(elapsedSeconds);
          localStorage.setItem("elapsedTime:jobs", elapsedSeconds.toString());
        }
      }
    }
  }, [startTime, connection]);

  useEffect(() => {
    if (connection) {
      const intervalId = setInterval(async () => {
        const currentTime = Date.now();
        const timeDifference = Math.floor((currentTime - startTime) / 1000);

        if (timeDifference >= 60) {
          await startJob();
          setStartTime(currentTime);
          setElapsedTime(0);
          localStorage.setItem("startTime:jobs", currentTime.toString());
          localStorage.setItem("elapsedTime:jobs", "0");
        } else {
          setElapsedTime((prevElapsedTime) => prevElapsedTime + 1);
          localStorage.setItem(
            "elapsedTime:jobs",
            (elapsedTime + 1).toString()
          );
        }
      }, 1000);

      return () => clearInterval(intervalId);
    }
  }, [elapsedTime, startJob, startTime, connection]);
